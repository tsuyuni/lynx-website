{/*
* This file is generated by @lynx-js/tool-typedoc.
* Do not edit this file directly.
* @generated
*/}

{/* Import all components as Lynx to allow dynamic lookup in TSDoc writings. */}
import * as Lynx from '@lynx';

[react](/api/react/index.mdx) / directives

# ディレクティブ

## `'background only'`

`'background only'` ディレクティブを使用すると、バックグラウンドスレッドでのみ実行される関数をマークできます。他のスレッドでは、マークされた関数の本体が削除されます。

関数をバックグラウンドのみの実行としてマークするには、関数本体の最初の行に `'background only'` ディレクティブを追加します。

```ts
function bgOnlyAction(pureCallback) {
  'background only';
  lynx.getJSModule('GlobalEventEmitter').addListener('eventName', pureCallback);
}
```

生成された出力のメインスレッド部分では、この関数は次のように置き換えられます。

```ts
function bgOnlyAction(pureCallback) {}
```

通常、イベントリスナーや JSB の呼び出しのような副作用のあるコードはバックグラウンドスレッドでのみ実行されるべきです。このような関数を `'background only'` としてマークすることで、バンドルサイズを大幅に削減できます。

`'background only'` を使用する方法の一つとして、カスタムフックとの組み合わせがあります。例えば、以下の `useFirstRender` は、コンポーネントが最初にレンダリングされたときにロジックを実行するためのユーザー定義フックであり、イベントをリッスンするために使用されますが、イベントリスニングのロジックはメインスレッドで実行するべきではありません。このような場合に、`'background only'` ディレクティブを使用して関数をマークし、イベントリスニングのロジックをメインスレッドから削除します。

```ts
import {useFirstRender} from './useFirstRender';

function bgOnlyAction(pureCallback) {
  'background only';
  lynx.getJSModule('GlobalEventEmitter').addListener('eventName', pureCallback);
}

function Foo({ prop } ){
  const ref = useRef(null);
  useFirstRender(() => {
    bgOnlyAction(() => {
      // ...
    });
  });
  return <view>;
}
```

他のスレッドで削除されるのは、`'background only'` としてマークされたコードだけではありません。デフォルトで、`useEffect`、`useLayoutEffect` のパラメータや、イベントハンドラなどのコードの一部が削除されます。これらの部分については、対応する関数を `'background only'` としてマークする必要はありません。詳細については、[デュアルランタイムコード分割](react/thinking-in-reactlynx) を参照してください。

## `'main thread'`

`'main thread'` ディレクティブを使用すると、メインスレッド関数をマークできます。メインスレッド関数は [メインスレッドスクリプト](react/main-thread-script) システムの一部であり、メインスレッドでのみ実行できます。主にスムーズなアニメーションやジェスチャの処理のために使用されます。

バックグラウンドスレッド関数をメインスレッド関数に変換するには、関数の最初の行に `'main thread'` ディレクティブを追加します。

```tsx {7}
import { MainThread } from '@lynx-js/types';

export default function App() {
  const red = 'red';

  function handleTap(event: MainThread.TouchEvent) {
    'main thread';
    event.currentTarget.setStyleProperty('background-color', red);
  }

  return (
    <view main-thread:bindtap={handleTap}>
      <text>Hello World!</text>
    </view>
  );
}
```

メインスレッド関数は、上記の `red` の例のように、バックグラウンドスレッドから外部変数を自動的にキャプチャします。

メインスレッド関数をイベントハンドラとして使用する際、メインスレッド関数はイベントに関する基本情報を含む `event` パラメータを受け取ります。このとき、`event.target` および `event.currentTarget` は通常のイベントハンドラとは異なり、[`MainThread.Element`](api/lynx-api/main-thread/main-thread-element) オブジェクトとなります。このオブジェクトを使用することで、上記の [`setStyleProperty()`] の例のように、ノードプロパティの取得と設定を同期的に行うことができます。


注意事項:

- メインスレッド関数はメインスレッドでのみ実行できます。メインスレッド関数は互いに呼び出すことができます。
- キャプチャされた変数はスレッド間で `JSON.stringify()` を使用して受け渡されるため、これらの変数は JSON にシリアライズ可能である必要があります。
- メインスレッド関数は TTI (Time to Interactive) 後にのみ実行でき、初期画面ロード中には実行できません。
- メインスレッド関数は、ネストされた定義をサポートしません。
- クラスコンポーネントのコンストラクタ、ゲッタ、セッタは、メインスレッド関数として指定できません。
- 外部スコープからキャプチャされた変数をメインスレッド関数内で変更することはできません。

[`setStyleProperty()`]: api/lynx-api/main-thread/main-thread-element.html#elementsetstyleproperty
