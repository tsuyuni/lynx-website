{/*
* This file is generated by @lynx-js/tool-typedoc.
* Do not edit this file directly.
* @generated
*/}

{/* Import all components as Lynx to allow dynamic lookup in TSDoc writings. */}
import * as Lynx from '@lynx';

[react](/api/react/index.mdx) / directives

# ディレクティブ

## `'background only'`

`'background only'` ディレクティブを使用すると、バックグラウンドスレッドでのみ実行される関数をマークできます。他のスレッドでは、マークされた関数の本体が削除されます。

関数をバックグラウンドのみの実行としてマークするには、関数本体の最初の行に `'background only'` ディレクティブを追加します。

```ts
function bgOnlyAction(pureCallback) {
  'background only';
  lynx.getJSModule('GlobalEventEmitter').addListener('eventName', pureCallback);
}
```

生成された出力のメインスレッド部分では、この関数は次のように置き換えられます。

```ts
function bgOnlyAction(pureCallback) {}
```

通常、イベントリスナーや JSB の呼び出しのような副作用のあるコードはバックグラウンドスレッドでのみ実行されるべきです。このような関数を `'background only'` としてマークすることで、バンドルサイズを大幅に削減できます。

`'background only'` を使用する方法の一つとして、カスタムフックとの組み合わせがあります。例えば、以下の `useFirstRender` は、コンポーネントが最初にレンダリングされたときにロジックを実行するためのユーザー定義フックであり、イベントをリッスンするために使用されますが、イベントリスニングのロジックはメインスレッドで実行するべきではありません。このような場合に、`'background only'` ディレクティブを使用して関数をマークし、イベントリスニングのロジックをメインスレッドから削除します。

```ts
import {useFirstRender} from './useFirstRender';

function bgOnlyAction(pureCallback) {
  'background only';
  lynx.getJSModule('GlobalEventEmitter').addListener('eventName', pureCallback);
}

function Foo({ prop } ){
  const ref = useRef(null);
  useFirstRender(() => {
    bgOnlyAction(() => {
      // ...
    });
  });
  return <view>;
}
```

他のスレッドで削除されるのは、`'background only'` としてマークされたコードだけではありません。デフォルトで、`useEffect`、`useLayoutEffect` のパラメータや、イベントハンドラなどのコードの一部が削除されます。これらの部分については、対応する関数を `'background only'` としてマークする必要はありません。詳細については、[デュアルランタイムコード分割](react/thinking-in-reactlynx) を参照してください。

## `'main thread'`

`'main thread'` ディレクティブを使用すると、メインスレッド関数をマークできます。メインスレッド関数は [メインスレッドスクリプト](react/main-thread-script) システムの一部であり、メインスレッドでのみ実行できます。主にスムーズなアニメーションやジェスチャの処理のために使用されます。

To convert a background thread function into a main thread function, simply add the `'main thread'` directive at the first line of the function:

```tsx {7}
import { MainThread } from '@lynx-js/types';

export default function App() {
  const red = 'red';

  function handleTap(event: MainThread.TouchEvent) {
    'main thread';
    event.currentTarget.setStyleProperty('background-color', red);
  }

  return (
    <view main-thread:bindtap={handleTap}>
      <text>Hello World!</text>
    </view>
  );
}
```

A main thread function will automatically capture external variables from the background thread when defined, such as `red` in the example above.

When using a main thread function as an event handler, the main thread function accepts an `event` parameter that contains basic information about the event. The `event.target` and `event.currentTarget` parameters differ from those in regular event handlers; they are [`MainThread.Element`](api/lynx-api/main-thread/main-thread-element) objects. This object allows you to conveniently synchronize the retrieval and setting of node properties, such as using [`setStyleProperty()`] in the example.

Some important notes:

- Main thread functions can and must only run on the main thread. Main thread functions can call each other.
- Captured variables need to be passed between threads using `JSON.stringify()`, so they must be serializable to JSON.
- Main thread functions can only execute after TTI (Time to Interactive). This means they cannot execute during the initial screen load.
- Main thread functions do not support nested definitions.
- The constructor, getter, and setter of class components do not support being specified as main thread functions.
- You cannot modify variables captured from the external scope within a main thread function.

[`setStyleProperty()`]: api/lynx-api/main-thread/main-thread-element.html#elementsetstyleproperty
